# Computational Scripts for GB Codes Classification

This directory contains the computational scripts used to derive and verify the classification results for (2,2)-Generalized Bicycle (GB) codes presented in the main repository and the associated paper.
You will find here Magma algorithms utilized for determining the minimum distance of the quantum codes.

These scripts are provided to ensure the reproducibility of our findings.

## Auxiliary functions 

R<X> := PolynomialRing(GF(2));

// Circulant matrix(l,p) : 

    Purpose : 
        Takes a list or sequence p representing the first row of the matrix and a dimension l. 
        It then "pads" the first row with zeros if it's shorter than l, ensuring the matrix is of the specified square dimension l x l. 
        Each subsequent row is generated by cyclically shifting the previous row to the right.

  Parameters:
      l (integer): The desired dimension of the square circulant matrix (i.e., l x l).  
      p (sequence of elements from GF(2)): A sequence representing the elements of the first row of the circulant matrix. This sequence will be extended with zeros if its length is less than l.


CirculantMatrix := function(l, p)
    if #p gt l then
        error "rows too large";
    end if;

    while #p lt l do
        Append(~p, GF(2)!0);
    end while;

    m := ZeroMatrix(GF(2), l);
    for i := 1 to l do
        for j := 1 to l do
            m[i, j] := p[1 + (j - i) mod l];
        end for;
    end for;
    return m;
end function;


------

// compute_d_css_GB_2_2(n, polA, polB) : 

    Purpose :
    This Magma function computes the minimum distance d of (2,2)-Generalized Bicycle (GB) codes. 
    Given the parameter n and two polynomials polA and polB), the function constructs the corresponding parity check matrices H_X and H_Z, determines their associated linear codes, and then iteratively searches for the minimum distance.

    The minimum distance d this CSS code is defined as the minimum Hamming weight of any non-trivial codeword in the kernel of H_X and not in the row-space of H_Z.
    This function efficiently finds this d by comparing the number of codewords of increasing weight in the relevant linear codes.

    Imput : 
    n (integer) : which is greater than 1. 
    polA (polynomial over textGF(2)) of degree < n 
    polB (polynomial over textGF(2)) of degree < n 

    Output : 
    < 2*n, 2, d > : where d is the minimum distance of the quantum Generalized Bicycle code GB(polA, polB, n)


Your existing calcul_d_css_GB_2_2 function
compute_d_css_GB_2_2 := function(n, polA, polB)
    two_n := 2 * n;

    listeA := Eltseq(polA);
    listeB := Eltseq(polB);

    A := CirculantMatrix(n, listeA);
    B := CirculantMatrix(n, listeB);

    HX := HorizontalJoin(A, B);
    HZ := HorizontalJoin(Transpose(B), Transpose(A));

    LignesGz := LinearCode(HZ);
    KerGx := Dual(LinearCode(HX));

    d := 2;
    while d le two_n do
        WLignesGz := #Words(LignesGz, d : Method := "Zimmermann");
        WKerGx := #Words(KerGx, d: Method := "Zimmermann", NumWords := WLignesGz + 1);
        if WKerGx ne WLignesGz then
            break;
        end if;
        d := d + 1;
    end while;

    return <2*n, 2, d>;
end function;

--------
//  process_and_display_codes(list_of_triplets)

Purpose : 
    This Magma procedure is designed to process a list of (2,2)-Generalized Bicycle (GB) code triplets and organize them by their quantum code parameters [[2n,k,d]]. 
    For each unique set of parameters, it then displays the corresponding GB codes.
    This procedure acts as a key component of the classification output, allowing for structured and readable presentation of the results.
    
    The procedure first iterates through each GB code triplet (containing n, PolA, PolB), calculates its quantum code parameters (length, dimension, minimum distance) using the compute_d_css_GB_2_2 function.
    Then groups these triplets by their calculated parameters in an associative array. 
    Finally, it sorts these parameter groups by their minimum distance and prepares them for display, ensuring that all codes for a given parameter set are presented together.

Parameters:
    list_of_triplets (list): A list where each element is a triplet [n, polA, polB] where
        n (integer): The parameter for the size of the circulant matrices
        polA (polynomial over textGF(2))  of degree < n 
        polB (polynomial over textGF(2)) of degree < n 

Outputs:
Prints formatted output to the console that groups the processed GB codes by their quantum parameters and then lists the specific GB codes that yield those parameters.


process_and_display_codes := procedure(list_of_triplets)
    // Associative array to group codes by their quantum parameters [length, dimension, distance]
    regroup_by_parameters := AssociativeArray();

    // Iterate through each [n, PolA, PolB] triplet
    for triplet in list_of_triplets do
        n_val := triplet[1];
        polA_val := triplet[2];
        polB_val := triplet[3];

        // Calculate the quantum code parameters [length, dimension, distance]
        current_parameters := compute_d_css_GB_2_2(n_val, polA_val, polB_val);

        // Use the parameters as a key for grouping
        parameters_key := current_parameters;

        // Add the current triplet to the group corresponding to its parameters
        if IsDefined(regroup_by_parameters, parameters_key) then
            Append(~regroup_by_parameters[parameters_key], triplet);
        else
            regroup_by_parameters[parameters_key] := [triplet];
        end if;
    end for;

    // Get all unique parameter keys from the associative array
    all_param_keys := [ k : k in Keys(regroup_by_parameters) ];

    // Define a custom comparison function for sorting keys by their minimum distance (the third element)
    compare_keys_by_distance := function(key1, key2)
        distance1 := key1[3];
        distance2 := key2[3];

        if distance1 lt distance2 then
            return -1; // key1 comes before key2
        elif distance1 gt distance2 then
            return 1;  // key1 comes after key2
        else
            return 0;  // keys are equal in terms of distance
        end if;
    end function;

    // Sort the list of parameter keys using the custom comparison function
    Sort(~all_param_keys, compare_keys_by_distance);

    // Loop through the sorted parameter keys and display the grouped codes
    for parameters_key in all_param_keys do
        length := parameters_key[1];
        dimension := parameters_key[2];
        distance := parameters_key[3];

        // Format the display line for the parameters
        display_line := Sprintf("[| %o, %o, %o |] : ", length, dimension, distance);

        // Get all triplets associated with the current parameters
        associated_triplets := regroup_by_parameters[parameters_key];

        // Prepare strings for each associated triplet (e.g., "GB(n, X^a+1, X^b+1)")
        triplets_strings := [];
        for t in associated_triplets do
            n_display := t[1];
            polA_display := t[2];
            polB_display := t[3];
            Append(~triplets_strings, Sprintf("GB(%o, %o, %o)", n_display, polA_display, polB_display));
        end for;

        // Join the triplet strings and print the final line
        print display_line cat Join(triplets_strings, ", ");
    end for;
end procedure;
